"""
Build script for creating a Python-compatible dynamic library using PackageCompiler.jl

This script compiles SubmodularMinimization.jl into a C-compatible dynamic library
that can be loaded from Python via ctypes.

Usage:
    julia build_python_library.jl

Output:
    - Creates a library in `python_lib/` directory
    - Includes shared library (.so/.dylib/.dll)
    - Includes C header files
    - Creates a minimal Python wrapper

Requirements:
    - PackageCompiler.jl must be installed
    - Julia 1.6+ recommended
"""

using Pkg

# Ensure PackageCompiler is available
try
    using PackageCompiler
catch e
    println("Installing PackageCompiler.jl...")
    Pkg.add("PackageCompiler")
    using PackageCompiler
end

# Ensure the current package is available
Pkg.activate(".")
using SubmodularMinimization

# Build configuration
const LIB_NAME = "libsubmodular"
const OUTPUT_DIR = "python_lib"
const PRECOMPILE_FILE = "build_precompile.jl"

# Create precompilation script
println("Creating precompilation script...")
precompile_content = """
# Precompilation script for SubmodularMinimization Python library
using SubmodularMinimization

# Load the Python interface to ensure @ccallable functions are compiled
include("src/python_interface.jl")

# Precompile common function types and sizes
println("Precompiling common function types...")

# Test concave functions
for n in [5, 10, 20, 50]
    for alpha in [0.3, 0.5, 0.7, 0.9]
        try
            f = ConcaveSubmodularFunction(n, alpha)
            S_min, min_val, x, iters = fujishige_wolfe_submodular_minimization(f; Œµ=1e-4, verbose=false)
            is_sub, violations, total = is_submodular(f; verbose=false)
            is_opt, improvement, better_val = is_minimiser(S_min, f; verbose=false)
        catch e
            # Ignore errors during precompilation
        end
    end
end

# Test cut functions  
for n in [4, 8, 12, 20]
    try
        f = create_random_cut_function(n, 0.3)
        S_min, min_val, x, iters = fujishige_wolfe_submodular_minimization(f; Œµ=1e-4, verbose=false)
    catch e
        # Ignore errors during precompilation
    end
end

# Test other function types
try
    f = SquareRootFunction(10)
    fujishige_wolfe_submodular_minimization(f; Œµ=1e-4, verbose=false)
    
    f = MatroidRankFunction(10, 5)
    fujishige_wolfe_submodular_minimization(f; Œµ=1e-4, verbose=false)
    
    f = create_bipartite_matching(5, 5, 0.4)
    fujishige_wolfe_submodular_minimization(f; Œµ=1e-4, verbose=false)
catch e
    # Ignore errors during precompilation
end

println("Precompilation complete!")
"""

# Write precompilation script
open(PRECOMPILE_FILE, "w") do io
    write(io, precompile_content)
end

# Create the library
println("Building dynamic library with PackageCompiler...")
println("This may take several minutes on first run...")

try
    create_library(
        ".",  # Current package
        OUTPUT_DIR;
        lib_name = LIB_NAME,
        precompile_execution_file = PRECOMPILE_FILE,
        force = true,  # Overwrite existing library
        header_files = ["src/python_interface.h"]  # We'll create this
    )
    
    println("‚úÖ Library built successfully!")
    println("üìÅ Output directory: $OUTPUT_DIR")
    println("üìö Library name: $LIB_NAME")
    
catch e
    if isa(e, SystemError) && occursin("header_files", string(e))
        # Try without header files if they don't exist
        println("Header file not found, building without custom headers...")
        create_library(
            ".",
            OUTPUT_DIR;
            lib_name = LIB_NAME,
            precompile_execution_file = PRECOMPILE_FILE,
            force = true
        )
        println("‚úÖ Library built successfully!")
    else
        println("‚ùå Error building library: $e")
        rethrow(e)
    end
end

# Create a simple C header file for reference
header_content = """
/*
 * SubmodularMinimization.jl C Interface
 * Generated by PackageCompiler.jl
 */

#ifndef SUBMODULAR_MINIMIZATION_H
#define SUBMODULAR_MINIMIZATION_H

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

// Function type constants
#define FUNC_TYPE_CONCAVE 1
#define FUNC_TYPE_CUT 2
#define FUNC_TYPE_SQRT 3
#define FUNC_TYPE_MATROID 4
#define FUNC_TYPE_BIPARTITE_MATCHING 5
#define FUNC_TYPE_FACILITY_LOCATION 6
#define FUNC_TYPE_CALLBACK 7

// Error codes
#define SUCCESS 0
#define ERROR_INVALID_FUNCTION_TYPE -1
#define ERROR_INVALID_PARAMETERS -2
#define ERROR_CONVERGENCE_FAILED -3
#define ERROR_MEMORY_ALLOCATION -4

// Fujishige-Wolfe submodular minimization solver
int32_t fujishige_wolfe_solve_c(
    int32_t func_type,
    double* params,
    int32_t n_params,
    int32_t n,
    double tolerance,
    int32_t max_iterations,
    int32_t** result_set,
    double* result_value,
    int32_t* result_iterations
);

// Direct Wolfe algorithm (returns minimum norm point)
int32_t wolfe_algorithm_c(
    int32_t func_type,
    double* params,
    int32_t n_params,
    int32_t n,
    double tolerance,
    int32_t max_iterations,
    double** result_x,
    int32_t* result_iterations,
    int32_t* converged
);

// Check if function is submodular
int32_t check_submodular_c(
    int32_t func_type,
    double* params,
    int32_t n_params,
    int32_t n,
    int32_t* violations
);

// Check if set is optimal
int32_t is_minimiser_c(
    int32_t func_type,
    double* params,
    int32_t n_params,
    int32_t n,
    int32_t* candidate_set,
    int32_t set_size,
    double* improvement_value
);

// Get function type constants
int32_t get_function_type_constants(
    int32_t* concave,
    int32_t* cut,
    int32_t* sqrt,
    int32_t* matroid,
    int32_t* bipartite,
    int32_t* facility
);

// Python callback registration and testing
int32_t register_python_callback(void* callback_ptr);
int32_t test_python_callback(int32_t* indices, int32_t n_indices, double* result);

// Memoization cache management
int32_t clear_memoization_cache();
int32_t get_cache_stats(int32_t* cache_hits, int32_t* cache_misses, int32_t* cache_size);
int32_t set_cache_enabled(int32_t enabled);

// Free memory allocated by Julia
int32_t free_result_array(int32_t* ptr);

#ifdef __cplusplus
}
#endif

#endif // SUBMODULAR_MINIMIZATION_H
"""

# Write header file
header_path = joinpath(OUTPUT_DIR, "include", "submodular_minimization.h")
mkpath(dirname(header_path))
open(header_path, "w") do io
    write(io, header_content)
end

println("üìÑ Created C header file: $header_path")

# Clean up
rm(PRECOMPILE_FILE; force=true)

# Instructions for use
println("""

üéâ Build Complete!

The dynamic library has been created in the '$OUTPUT_DIR' directory.

Next steps:
1. Set library path: export LD_LIBRARY_PATH=\$(pwd)/$OUTPUT_DIR/lib:\$LD_LIBRARY_PATH
   (On macOS: export DYLD_LIBRARY_PATH=\$(pwd)/$OUTPUT_DIR/lib:\$DYLD_LIBRARY_PATH)
   
2. Test the library with Python:
   python3 -c "import ctypes; lib = ctypes.CDLL('./$OUTPUT_DIR/lib/$LIB_NAME.so'); print('Library loaded successfully!')"
   
3. Use the Python wrapper (once created):
   python3 test_python_wrapper.py

Library contents:
""")

# Show library contents
if isdir(OUTPUT_DIR)
    for (root, dirs, files) in walkdir(OUTPUT_DIR)
        for file in files
            relpath = joinpath(root, file)
            println("  üìÑ $relpath")
        end
    end
end